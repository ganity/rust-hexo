use crate::models::{Category, Page, Post, SiteConfig, Tag};
use crate::plugins::{PluginManager, PluginHook, PluginContext};
use crate::theme::renderer::ThemeRenderer;
use crate::core::generator::HtmlGenerator;
use anyhow::{Context, Result};
use chrono::{Utc, TimeZone};
use colored::Colorize;
use gray_matter::Matter;
use gray_matter::engine::YAML;
use notify::{Config as NotifyConfig, Event, RecommendedWatcher, RecursiveMode, Watcher};
use rayon::prelude::*;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::{Arc, RwLock};
use std::sync::mpsc;
use std::time::Duration;
use tracing::{debug, info, warn};
use walkdir::WalkDir;
use yaml_rust2::{YamlLoader, Yaml};
use serde_yaml::Mapping;
use gray_matter::Pod;
use serde_yaml::Value;
use pulldown_cmark::{html, Options, Parser};
use std::fs;
use crate::models::config::Config;
use crate::models::{Config, Context, ContextBuilder, Post, Page, Category, Tag};
use crate::theme::renderer::ThemeRenderer;
use crate::plugins::{Plugin, PluginContext, PluginHook, PluginManager, ContentType};

/// Hexo引擎的核心实现
#[derive(Clone)]
pub struct Engine {
    /// 基础目录
    pub base_dir: PathBuf,
    /// 源文件目录
    pub source_dir: PathBuf,
    /// 公共目录（输出）
    pub public_dir: PathBuf,
    /// 主题目录
    pub theme_dir: PathBuf,
    /// 脚手架目录
    pub scaffold_dir: PathBuf,
    /// 站点配置
    pub config: Config,
    /// 主题配置
    pub theme_config: HashMap<String, serde_yaml::Value>,
    /// 所有文章
    pub posts: Arc<RwLock<Vec<Post>>>,
    /// 所有页面
    pub pages: Arc<RwLock<Vec<Page>>>,
    /// 所有分类
    pub categories: Arc<RwLock<Vec<Category>>>,
    /// 所有标签
    pub tags: Arc<RwLock<Vec<Tag>>>,
    /// 是否处于监听状态
    is_watching: Arc<RwLock<bool>>,
    /// 插件管理器
    pub plugin_manager: PluginManager,
    /// 主题渲染器
    theme_renderer: Option<ThemeRenderer>,
}

impl Engine {
    /// 创建一个新的引擎实例
    pub fn new(base_dir: PathBuf) -> Result<Self> {
        info!("初始化 Hexo 引擎...");
        info!("工作目录: {}", base_dir.display());
        
        // 创建必要的目录
        let source_dir = base_dir.join("source");
        let public_dir = base_dir.join("public");
        let theme_dir = base_dir.join("themes").join("default");
        let scaffold_dir = base_dir.join("scaffolds");

        // 检查必要目录是否存在
        if !source_dir.exists() {
            fs::create_dir_all(&source_dir)?;
            info!("创建 source 目录");
        }
        
        // 配置文件
        let config_path = base_dir.join("_config.yml");
        let config = if config_path.exists() {
            Config::load(&config_path)?
        } else {
            let config = Config::default();
            config.save(&config_path)?;
            info!("创建默认配置文件");
            config
        };
        
        // 克隆base_dir以便在后续使用
        let base_dir_clone = base_dir.clone();
        
        Ok(Self {
            base_dir: base_dir.clone(),
            source_dir,
            public_dir,
            theme_dir,
            scaffold_dir,
            config,
            theme_config: HashMap::new(),
            posts: Arc::new(RwLock::new(Vec::new())),
            pages: Arc::new(RwLock::new(Vec::new())),
            categories: Arc::new(RwLock::new(Vec::new())),
            tags: Arc::new(RwLock::new(Vec::new())),
            is_watching: Arc::new(RwLock::new(false)),
            plugin_manager: PluginManager::new(base_dir_clone, PluginContext::default()),
            theme_renderer: None,
        })
    }
    
    /// 加载主题配置
    fn load_theme_config(theme_dir: &Path, site_config: &Config) -> Result<HashMap<String, serde_yaml::Value>> {
        let theme_config_path = theme_dir.join("_config.yml");
        let mut theme_config = HashMap::new();
        
        if theme_config_path.exists() {
            let config_str = std::fs::read_to_string(&theme_config_path)
                .with_context(|| format!("Failed to read theme config file: {}", theme_config_path.display()))?;
            
            theme_config = serde_yaml::from_str(&config_str)
                .with_context(|| "Failed to parse theme _config.yml")?;
        }
        
        // 合并站点配置中的主题配置
        if let Some(site_theme_config) = &site_config.theme_config {
            if let serde_yaml::Value::Mapping(mapping) = site_theme_config {
                for (key, value) in mapping {
                    if let Some(key_str) = key.as_str() {
                        theme_config.insert(key_str.to_string(), value.clone());
                    }
                }
            }
        }
        
        Ok(theme_config)
    }
    
    /// 初始化引擎
    pub fn init(&mut self) -> Result<()> {
        info!("初始化 Hexo 引擎...");
        
        // 初始化插件管理器
        let plugin_context = self.create_plugin_context();
        self.plugin_manager.set_context(plugin_context);
        self.plugin_manager.init()?;
        
        // 初始化主题渲染器
        let mut theme_renderer = ThemeRenderer::new(&self.base_dir, self.config.clone())?;
        
        // 将插件管理器传递给主题渲染器
        theme_renderer.set_plugin_manager(self.plugin_manager.clone());
        
        // 保存主题渲染器
        self.theme_renderer = Some(theme_renderer);
        
        info!("{}", "Initialization complete.".green());
        Ok(())
    }
    
    /// 加载配置文件
    pub fn load_config(&mut self) -> Result<()> {
        let config_path = self.base_dir.join("_config.yml");
        let config = std::fs::read_to_string(&config_path)?;
        let config: Config = serde_yaml::from_str(&config)?;
        self.config = config.clone();
        self.plugin_manager.update_config(config);
        Ok(())
    }
    
    /// 运行引擎，完成整个生成过程
    pub async fn run(&self) -> Result<()> {
        debug!("Running engine...");
        
        // 调用插件钩子：生成前
        self.plugin_manager.execute_hook(PluginHook::BeforeGenerate)?;
        
        // 读取文章和页面
        self.load_posts_and_pages()?;
        self.process_categories_and_tags()?;
        
        // 调用插件钩子：路由生成前
        self.plugin_manager.execute_hook(PluginHook::BeforeRouteGenerate)?;
        
        // 生成静态文件
        self.generate().await?;
        
        // 调用插件钩子：生成后
        self.plugin_manager.execute_hook(PluginHook::AfterGenerate)?;
        
        Ok(())
    }
    
    /// 加载文章和页面
    fn load_posts_and_pages(&self) -> Result<()> {
        info!("Loading posts and pages...");
        
        // 加载文章
        let posts_dir = self.source_dir.join("_posts");
        info!("Loading posts from: {}", posts_dir.display());
        
        let mut found_posts = Vec::new();
        let matter = Matter::<YAML>::new();
        
        if posts_dir.exists() {
            for entry in walkdir::WalkDir::new(&posts_dir) {
                let entry = entry?;
                let path = entry.path();
                
                // 只处理 .md 文件
                if !path.is_file() || path.extension().and_then(|s| s.to_str()) != Some("md") {
                    continue;
                }
                
                // 读取文件内容
                let content = std::fs::read_to_string(path)?;
                
                // 解析 Front Matter
                let result = matter.parse(&content);
                
                // 获取 YAML 数据
                let yaml_data = if let Some(data) = result.data {
                    data
                } else {
                    continue;
                };
                
                // 获取标题
                let title = if let Ok(title) = yaml_data["title"].as_string() {
                    title
                } else {
                    // 如果没有标题，使用文件名
                    path.file_stem()
                        .and_then(|s| s.to_str())
                        .unwrap_or("Untitled")
                        .to_string()
                };
                
                // 获取分类
                let categories = if let Ok(cats) = yaml_data["categories"].as_vec() {
                    cats.iter()
                        .filter_map(|v| v.as_string().ok())
                        .collect()
                } else if let Ok(cat) = yaml_data["categories"].as_string() {
                    vec![cat]
                } else {
                    Vec::new()
                };
                
                // 获取标签
                let tags = if let Ok(tags) = yaml_data["tags"].as_vec() {
                    tags.iter()
                        .filter_map(|v| v.as_string().ok())
                        .collect()
                } else if let Ok(tag) = yaml_data["tags"].as_string() {
                    vec![tag]
                } else {
                    Vec::new()
                };
                
                // 获取摘要和内容
                let content = result.content;
                let excerpt = if let Some(pos) = content.find("<!-- more -->") {
                    Some(content[..pos].trim().to_string())
                } else {
                    None
                };
                
                // 解析日期
                let date = if let Ok(date_str) = yaml_data["date"].as_string() {
                    match chrono::DateTime::parse_from_str(&date_str, "%Y-%m-%d %H:%M:%S %z") {
                        Ok(dt) => dt.with_timezone(&Utc),
                        Err(_) => {
                            // 尝试另一种格式
                            match chrono::NaiveDateTime::parse_from_str(&date_str, "%Y-%m-%d %H:%M:%S") {
                                Ok(dt) => Utc.from_utc_datetime(&dt),
                                Err(_) => Utc::now(), // 如果无法解析，使用当前时间
                            }
                        }
                    }
                } else {
                    // 如果没有日期，使用文件的修改时间
                    let metadata = std::fs::metadata(path)?;
                    let modified = metadata.modified()?;
                    let system_time: chrono::DateTime<Utc> = modified.into();
                    system_time
                };
                
                // 创建前置数据的HashMap
                let mut front_matter = HashMap::new();
                if let Ok(hash) = yaml_data.as_hashmap() {
                    for (k, v) in hash {
                        let value = match v {
                            Pod::String(s) => Value::String(s),
                            Pod::Integer(i) => Value::Number(serde_yaml::Number::from(i)),
                            Pod::Float(f) => Value::Number(serde_yaml::Number::from(f)),
                            Pod::Boolean(b) => Value::Bool(b),
                            Pod::Array(arr) => Value::Sequence(arr.into_iter().map(pod_to_value).collect()),
                            Pod::Hash(map) => Value::Mapping(map.into_iter().map(|(k, v)| (Value::String(k), pod_to_value(v))).collect()),
                            Pod::Null => Value::Null,
                        };
                        front_matter.insert(k, value);
                    }
                }
                
                // 创建文章的路径
                let filename = path.file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unknown")
                    .to_string();
                let output_path = format!("posts/{}.html", filename);
                let permalink = format!("/{}", output_path);
                
                // 创建新的博客文章
                let post = Post {
                    title: title.clone(),
                    date,
                    updated: None,
                    comments: true,
                    layout: "post".to_string(),
                    content,
                    rendered_content: None,
                    source: path.to_path_buf(),
                    path: output_path,
                    permalink,
                    excerpt,
                    url: None,
                    categories,
                    tags,
                    front_matter,
                };
                
                found_posts.push(post);
                debug!("Added post: {}", title);
            }
        }
        
        // 将找到的文章按日期排序（最新的在前）
        found_posts.sort_by(|a, b| b.date.cmp(&a.date));
        
        // 保存文章
        {
            let mut posts = self.posts.write().unwrap();
            *posts = found_posts;
        }
        
        // 加载页面
        let pages_dir = self.source_dir.join("_pages");
        let mut found_pages = Vec::new();
        
        if pages_dir.exists() {
            info!("Loading pages from: {}", pages_dir.display());
            
            for entry in WalkDir::new(&pages_dir)
                .into_iter()
                .filter_map(|e| e.ok())
                .filter(|e| {
                    let path = e.path();
                    path.is_file() && path.extension().map_or(false, |ext| ext == "md" || ext == "markdown")
                }) 
            {
                let path = entry.path();
                debug!("Found page file: {}", path.display());
                
                // 读取文件内容
                let content = std::fs::read_to_string(path)?;
                
                // 解析front matter
                let result = matter.parse(&content);
                let yaml_data = if let Some(data_yaml) = result.data {
                    // 将数据转换为字符串，再解析为yaml_rust2::Yaml
                    let data_str = format!("{:?}", data_yaml);
                    let parse_result = YamlLoader::load_from_str(&data_str);
                    match parse_result {
                        Ok(docs) if !docs.is_empty() => docs[0].clone(),
                        _ => Yaml::Hash(yaml_rust2::yaml::Hash::new())
                    }
                } else {
                    Yaml::Hash(yaml_rust2::yaml::Hash::new())
                };
                
                // 构建页面对象
                let title = if let Some(title_str) = yaml_data["title"].as_str() {
                    title_str.to_string()
                } else {
                    // 如果没有标题，使用文件名
                    path.file_stem()
                        .and_then(|s| s.to_str())
                        .unwrap_or("Untitled")
                        .to_string()
                };
                
                // 解析日期
                let date = if let Some(date_str) = yaml_data["date"].as_str() {
                    match chrono::DateTime::parse_from_str(&date_str, "%Y-%m-%d %H:%M:%S %z") {
                        Ok(dt) => dt.with_timezone(&Utc),
                        Err(_) => {
                            // 尝试另一种格式
                            match chrono::NaiveDateTime::parse_from_str(&date_str, "%Y-%m-%d %H:%M:%S") {
                                Ok(dt) => Utc.from_utc_datetime(&dt),
                                Err(_) => Utc::now(), // 如果无法解析，使用当前时间
                            }
                        }
                    }
                } else {
                    // 如果没有日期，使用文件的修改时间
                    let metadata = std::fs::metadata(path)?;
                    let modified = metadata.modified()?;
                    let system_time: chrono::DateTime<Utc> = modified.into();
                    system_time
                };
                
                // 创建前置数据的HashMap
                let mut front_matter = HashMap::new();
                if let Some(hash) = yaml_data.as_hash() {
                    for (k, v) in hash {
                        if let Some(key) = k.as_str() {
                            let value = yaml_to_serde_value(v.clone());
                            front_matter.insert(key.to_string(), value);
                        }
                    }
                }
                
                // 创建页面的URL路径
                let filename = path.file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or("unknown")
                    .to_string();
                
                let output_path = format!("{}.html", filename);
                let permalink = format!("/{}", output_path);
                
                // 创建新的页面
                let page = Page {
                    title: title.clone(),
                    date,
                    updated: None,
                    comments: true,
                    layout: "page".to_string(),
                    content: result.content.clone(),
                    rendered_content: None,
                    source: path.to_path_buf(),
                    path: output_path,
                    permalink,
                    front_matter,
                };
                
                // 添加到页面集合
                found_pages.push(page);
                debug!("Added page: {}", title);
            }
        }
        
        // 将找到的页面按日期排序（最新的在前）
        found_pages.sort_by(|a, b| b.date.cmp(&a.date));
        
        // 保存页面
        {
            let mut pages = self.pages.write().unwrap();
            *pages = found_pages;
        }
        
        // 记录加载的文章和页面数量
        info!("Loaded {} posts and {} pages", 
            self.posts.read().unwrap().len(),
            self.pages.read().unwrap().len());
        
        Ok(())
    }
    
    /// 处理分类和标签
    fn process_categories_and_tags(&self) -> Result<()> {
        debug!("Processing categories and tags...");
        
        let posts = self.posts.read().unwrap();
        
        // 收集所有分类
        let mut category_map: HashMap<String, usize> = HashMap::new();
        for post in posts.iter() {
            for category in &post.categories {
                *category_map.entry(category.clone()).or_insert(0) += 1;
            }
        }
        
        // 创建分类列表
        let mut categories = Vec::new();
        for (name, count) in category_map {
            let slug = slug::slugify(&name);
            let path = format!("categories/{}", slug);
            
            categories.push(Category {
                name,
                slug,
                path,
                parent: None, // 暂时不处理父子分类
                post_count: count,
            });
        }
        
        // 收集所有标签
        let mut tag_map: HashMap<String, usize> = HashMap::new();
        for post in posts.iter() {
            for tag in &post.tags {
                *tag_map.entry(tag.clone()).or_insert(0) += 1;
            }
        }
        
        // 创建标签列表
        let mut tags = Vec::new();
        for (name, count) in tag_map {
            let slug = slug::slugify(&name);
            let path = format!("tags/{}", slug);
            
            tags.push(Tag {
                name,
                slug,
                path,
                post_count: count,
            });
        }
        
        // 保存分类
        let mut categories_lock = self.categories.write().unwrap();
        *categories_lock = categories;
        
        // 保存标签
        let mut tags_lock = self.tags.write().unwrap();
        *tags_lock = tags;
        
        debug!("Processed {} categories and {} tags", categories_lock.len(), tags_lock.len());
        
        Ok(())
    }
    
    /// 生成静态网站
    pub async fn generate(&self) -> Result<()> {
        info!("Generating HTML files...");
        
        // 从锁中读取数据
        let posts = self.posts.read().unwrap();
        let _categories = self.categories.read().unwrap();
        let _tags = self.tags.read().unwrap();
        
        // 确保输出目录存在
        fs::create_dir_all(&self.public_dir)?;
        
        // 创建生成器
        let generator = HtmlGenerator::new(
            self.public_dir.clone(),
            SiteConfig {
                title: self.config.title.clone(),
                subtitle: self.config.subtitle.clone(),
                description: self.config.description.clone(),
                author: self.config.author.clone(),
                language: self.config.language.clone().unwrap_or_else(|| "en".to_string()),
                timezone: self.config.timezone.clone(),
                url: self.config.url.clone().unwrap_or_default(),
                root: self.config.root.clone().unwrap_or_default(),
                per_page: self.config.per_page.unwrap_or(10) as usize,
                theme: self.config.theme.clone().unwrap_or_else(|| "default".to_string()),
                deploy: None,
                theme_config: None,
                comments: None,
                search: None,
                extras: HashMap::new(),
            },
            self.base_dir.clone()
        );
        
        // 调用插件钩子：资源处理前
        self.plugin_manager.execute_hook(PluginHook::BeforeAssetProcess)?;
        
        // 复制静态资源
        info!("复制主题资源...");
        self.copy_theme_assets()?;
        
        // 生成静态文件
        info!("生成文章页面...");
        
        // 处理文章渲染
        let mut processed_posts = Vec::new();
        for post in posts.iter() {
            debug!("处理文章: {}", post.title);
            
            // 创建文章副本进行处理
            let mut post_clone = post.clone();
            
            // 创建插件上下文
            let mut context = self.create_plugin_context();
            context.current_post = Some(post_clone.clone());
            
            // 调用插件钩子：文章渲染前
            self.plugin_manager.execute_hook_with_context(PluginHook::BeforePostRender, &context)?;
            
            // 处理Markdown内容
            let plugins = self.plugin_manager.get_all_plugins()?;
            let mut content = post_clone.content.clone();
            
            // 通过每个插件处理Markdown内容
            for plugin in &plugins {
                content = plugin.process_markdown(&content)?;
            }
            
            // 将处理后的内容保存回文章
            post_clone.content = content;
            
            // 通过Markdown处理器渲染HTML
            let html_content = self.render_markdown_to_html(&post_clone.content)?;
            
            // 通过每个插件处理HTML内容
            let mut processed_html = html_content;
            for plugin in &plugins {
                processed_html = plugin.process_html(&processed_html)?;
            }
            
            // 保存渲染后的HTML
            post_clone.rendered_content = Some(processed_html);
            
            // 更新上下文中的文章
            context.current_post = Some(post_clone.clone());
            
            // 调用插件钩子：文章渲染后
            self.plugin_manager.execute_hook_with_context(PluginHook::AfterPostRender, &context)?;
            
            // 获取更新后的文章
            if let Some(updated_post) = context.current_post {
                post_clone = updated_post;
            }
            
            processed_posts.push(post_clone);
        }
        
        // 使用处理后的文章生成
        generator.generate(&processed_posts)?;
        
        // 调用插件钩子：资源处理后
        self.plugin_manager.execute_hook(PluginHook::AfterAssetProcess)?;
        
        info!("HTML文件生成成功");
        
        // 复制静态文件
        info!("复制静态文件...");
        self.copy_static_files()?;
        
        info!("生成完成");
        Ok(())
    }
    
    /// 将Markdown渲染为HTML
    fn render_markdown_to_html(&self, markdown: &str) -> Result<String> {
        // 创建Markdown解析选项
        let mut options = pulldown_cmark::Options::empty();
        options.insert(pulldown_cmark::Options::ENABLE_TABLES);
        options.insert(pulldown_cmark::Options::ENABLE_FOOTNOTES);
        options.insert(pulldown_cmark::Options::ENABLE_STRIKETHROUGH);
        options.insert(pulldown_cmark::Options::ENABLE_TASKLISTS);
        
        // 解析Markdown
        let parser = pulldown_cmark::Parser::new_ext(markdown, options);
        
        // 将解析结果渲染为HTML
        let mut html_output = String::new();
        pulldown_cmark::html::push_html(&mut html_output, parser);
        
        Ok(html_output)
    }
    
    /// 复制静态资源文件
    fn copy_static_files(&self) -> Result<()> {
        info!("Copying static files...");
        
        // 从源目录复制静态文件
        let static_dir = self.source_dir.join("static");
        if static_dir.exists() {
            for entry in walkdir::WalkDir::new(&static_dir) {
                let entry = entry?;
                if entry.file_type().is_file() {
                    let rel_path = entry.path().strip_prefix(&static_dir)?;
                    let dest_path = self.public_dir.join(rel_path);
                    
                    // 确保目标目录存在
                    if let Some(parent) = dest_path.parent() {
                        std::fs::create_dir_all(parent)?;
                    }
                    
                    // 复制文件
                    std::fs::copy(entry.path(), &dest_path)?;
                    debug!("Copied static file: {} -> {}", entry.path().display(), dest_path.display());
                }
            }
        }
        
        // 从主题目录复制静态文件
        let theme_static_dir = self.theme_dir.join("source");
        if theme_static_dir.exists() {
            for entry in walkdir::WalkDir::new(&theme_static_dir) {
                let entry = entry?;
                if entry.file_type().is_file() {
                    let rel_path = entry.path().strip_prefix(&theme_static_dir)?;
                    let dest_path = self.public_dir.join(rel_path);
                    
                    // 确保目标目录存在
                    if let Some(parent) = dest_path.parent() {
                        std::fs::create_dir_all(parent)?;
                    }
                    
                    // 复制文件
                    std::fs::copy(entry.path(), &dest_path)?;
                    debug!("Copied theme static file: {} -> {}", entry.path().display(), dest_path.display());
                }
            }
        }
        
        Ok(())
    }
    
    /// 复制主题资源
    fn copy_theme_assets(&self) -> Result<()> {
        let theme_source = self.theme_dir.join("source");
        let target_dir = self.public_dir.clone();
        
        if !theme_source.exists() {
            warn!("主题源目录不存在: {}", theme_source.display());
            return Ok(());
        }
        
        // 遍历主题的source目录
        let walker = WalkDir::new(&theme_source).into_iter();
        for entry in walker.filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() {
                let relative = path.strip_prefix(&theme_source)?;
                let target = target_dir.join(relative);
                
                // 确保目标目录存在
                if let Some(parent) = target.parent() {
                    fs::create_dir_all(parent)?;
                }
                
                // 复制文件
                fs::copy(path, &target)?;
                debug!("已复制: {} -> {}", path.display(), target.display());
            }
        }
        
        info!("主题资源复制成功");
        Ok(())
    }
    
    /// 启动本地服务器预览
    pub async fn server(&self, port: u16) -> Result<()> {
        info!("{}", format!("Starting server on http://localhost:{}", port).green());
        
        // 先生成静态文件
        self.generate().await?;
        
        // 创建HTTP服务器
        use crate::core::Server;
        let server = Server::new(self.public_dir.clone(), port);
        
        // 获取文件更改通知发送器，用于监视文件变化
        let _tx = server.get_sender();
        
        // 启动服务器
        server.start().await?;
        
        Ok(())
    }
    
    /// 开始监听文件变化
    pub async fn watch(&self) -> Result<()> {
        info!("{}", "Watching for file changes...".green());
        
        // 设置监听状态
        {
            let mut is_watching = self.is_watching.write().unwrap();
            *is_watching = true;
        }
        
        // 使用notify库监听文件变化
        use notify::{Config, Event, RecommendedWatcher, RecursiveMode, Watcher};
        use std::sync::mpsc;
        use std::time::Duration;
        
        // 创建通道以接收文件系统事件
        let (tx, rx) = mpsc::channel();
        
        // 创建一个监视器
        let mut watcher = RecommendedWatcher::new(
            move |res: Result<Event, notify::Error>| {
                if let Ok(event) = res {
                    let _ = tx.send(event);
                }
            },
            Config::default(),
        )?;
        
        // 监视源目录
        watcher.watch(&self.source_dir, RecursiveMode::Recursive)?;
        
        // 如果主题目录存在，也监视它
        if self.theme_dir.exists() {
            watcher.watch(&self.theme_dir, RecursiveMode::Recursive)?;
        }
        
        // 创建一个引擎的克隆，用于生成
        let engine = self.clone();
        
        // 在后台启动监视任务
        tokio::spawn(async move {
            // 创建一个防抖动计时器，避免频繁生成
            let mut last_event = std::time::Instant::now();
            let debounce_time = Duration::from_millis(500);
            
            loop {
                // 读取事件，设置超时
                match rx.recv_timeout(Duration::from_secs(1)) {
                    Ok(event) => {
                        // 只处理创建、修改和删除事件
                        match event.kind {
                            notify::EventKind::Create(_) | 
                            notify::EventKind::Modify(_) | 
                            notify::EventKind::Remove(_) => {
                                // 检查是否是我们关心的文件类型
                                for path in &event.paths {
                                    if let Some(ext) = path.extension() {
                                        if ext == "md" || ext == "markdown" || ext == "yml" || ext == "yaml" {
                                            // 更新最后事件时间
                                            last_event = std::time::Instant::now();
                                            break;
                                        }
                                    }
                                }
                            },
                            _ => {}
                        }
                    },
                    Err(mpsc::RecvTimeoutError::Timeout) => {
                        // 如果自上次事件以来已过去debounce时间，且有事件发生，则重新生成
                        if last_event.elapsed() >= debounce_time && last_event.elapsed() < Duration::from_secs(2) {
                            info!("File changes detected, regenerating...");
                            
                            // 重新生成静态文件
                            if let Err(e) = engine.generate().await {
                                eprintln!("Error regenerating: {}", e);
                            }
                            
                            // 重置最后事件时间
                            last_event = std::time::Instant::now() - Duration::from_secs(10);
                        }
                        
                        // 检查是否仍在监视
                        if !*engine.is_watching.read().unwrap() {
                            break;
                        }
                    },
                    Err(mpsc::RecvTimeoutError::Disconnected) => {
                        // 通道已关闭，结束监视
                        break;
                    }
                }
            }
        });
        
        Ok(())
    }
    
    /// 停止监听
    pub fn unwatch(&self) {
        let mut is_watching = self.is_watching.write().unwrap();
        *is_watching = false;
    }
    
    /// 创建新文章
    pub async fn new_post(&self, title: &str, path: Option<&str>) -> Result<PathBuf> {
        info!("{}", format!("Creating new post: {}", title).green());
        
        // 使用脚手架创建新文章
        let post_path = self.source_dir.join("_posts");
        std::fs::create_dir_all(&post_path)?;
        
        let slug = slug::slugify(title);
        let filename = match path {
            Some(p) => p.to_string(),
            None => format!("{}.md", slug),
        };
        
        let post_file = post_path.join(&filename);
        
        // 从脚手架生成Front Matter
        let now = Utc::now();
        let content = format!(
            "---\ntitle: {}\ndate: {}\ntags:\ncategories:\n---\n\n<!-- more -->\n",
            title,
            now.format("%Y-%m-%d %H:%M:%S")
        );
        
        std::fs::write(&post_file, content)?;
        
        info!("{}", format!("Post created: {}", post_file.display()).green());
        
        Ok(post_file)
    }
    
    /// 创建新页面
    pub async fn new_page(&self, title: &str, path: &str) -> Result<PathBuf> {
        info!("{}", format!("Creating new page: {}", title).green());
        
        // 创建页面逻辑，类似于创建文章
        let page_path = self.source_dir.join(path);
        std::fs::create_dir_all(&page_path)?;
        
        let page_file = page_path.join("index.md");
        
        // 从脚手架生成Front Matter
        let now = Utc::now();
        let content = format!(
            "---\ntitle: {}\ndate: {}\n---\n\n",
            title,
            now.format("%Y-%m-%d %H:%M:%S")
        );
        
        std::fs::write(&page_file, content)?;
        
        info!("{}", format!("Page created: {}", page_file.display()).green());
        
        Ok(page_file)
    }
    
    /// 清理生成的文件
    pub async fn clean(&mut self) -> Result<()> {
        info!("{}", "Cleaning...".green());
        
        // 删除公共目录
        if self.public_dir.exists() {
            std::fs::remove_dir_all(&self.public_dir)?;
            std::fs::create_dir_all(&self.public_dir)?;
        }
        
        // 清理插件
        self.plugin_manager.cleanup()?;
        
        info!("{}", "Cleaning complete.".green());
        Ok(())
    }
    
    /// 部署网站
    pub async fn deploy(&self) -> Result<()> {
        info!("{}", "Deploying website...".green());
        
        // 部署逻辑，根据配置可以部署到不同平台
        // 如GitHub Pages、FTP、SSH等
        
        info!("{}", "Deployment complete.".green());
        Ok(())
    }

    /// 启动插件热重载
    pub fn start_plugin_hot_reload(&mut self) -> Result<()> {
        self.plugin_manager.start_hot_reload()?;
        Ok(())
    }

    /// 停止插件热重载
    pub fn disable_plugin_hot_reload(&mut self) {
        info!("禁用插件热重载...");
        self.plugin_manager.stop_hot_reload();
        info!("插件热重载已禁用");
    }

    /// 创建插件上下文
    fn create_plugin_context(&self) -> PluginContext {
        let posts = self.posts.read().unwrap().clone();
        let pages = self.pages.read().unwrap().clone();
        let categories = self.categories.read().unwrap().clone();
        let tags = self.tags.read().unwrap().clone();

        info!("为插件创建上下文, 文章数量: {}, 页面数量: {}", posts.len(), pages.len());
        
        PluginContext {
            base_dir: self.base_dir.clone(),
            plugins_dir: self.base_dir.join("plugins"),
            theme_dir: self.theme_dir.clone(),
            config: self.config.clone(),
            posts,
            pages,
            categories,
            tags,
            current_post: None,
            current_page: None,
        }
    }

    /// 初始化插件系统
    fn init_plugins(&mut self) -> Result<()> {
        info!("初始化插件系统...");
        
        // 创建插件上下文
        let context = self.create_plugin_context();
        
        // 创建插件管理器
        let mut plugin_manager = PluginManager::new(self.config.base_dir.clone(), context);
        
        // 初始化插件管理器（加载插件）
        if let Err(e) = plugin_manager.init() {
            error!("插件系统初始化失败: {}", e);
            // 继续执行，不中断整个过程
        }
        
        // 保存插件管理器
        self.plugin_manager = Some(plugin_manager);
        
        Ok(())
    }
    
    /// 加载插件
    fn load_plugins(&mut self) -> Result<()> {
        if self.plugin_manager.is_none() {
            self.init_plugins()?;
        }
        
        info!("加载插件...");
        
        // 更新插件上下文
        let context = self.create_plugin_context()?;
        if let Some(plugin_manager) = &mut self.plugin_manager {
            plugin_manager.set_context(context);
        }
        
        Ok(())
    }

    /// 生成静态文件
    pub fn generate(&mut self) -> Result<()> {
        info!("开始生成静态文件...");
        
        // 检查输出目录是否存在，如果不存在则创建
        let public_dir = self.config.base_dir.join("public");
        if !public_dir.exists() {
            std::fs::create_dir_all(&public_dir)?;
        }
        
        // 初始化插件系统
        self.init_plugins()?;
        
        // 执行生成前钩子
        if let Some(plugin_manager) = &self.plugin_manager {
            if let Err(e) = plugin_manager.execute_hook(PluginHook::BeforeGenerate) {
                warn!("执行生成前钩子失败: {}", e);
                // 继续执行，不中断整个过程
            }
        }
        
        // 加载模板
        let mut renderer = self.load_theme()?;
        
        // 将插件的函数和过滤器注册到模板渲染器
        if let Some(plugin_manager) = &self.plugin_manager {
            if let Err(e) = plugin_manager.register_to_theme_renderer(&mut renderer) {
                warn!("注册插件模板函数和过滤器失败: {}", e);
                // 继续执行，不中断整个过程
            }
        }
        
        // 生成HTML文件
        self.generate_html(&renderer)?;
        
        // 复制主题静态资源
        self.copy_theme_assets()?;
        
        // 执行生成后钩子
        if let Some(plugin_manager) = &self.plugin_manager {
            if let Err(e) = plugin_manager.execute_hook(PluginHook::AfterGenerate) {
                warn!("执行生成后钩子失败: {}", e);
                // 继续执行，不中断整个过程
            }
        }
        
        info!("静态文件生成完成");
        
        Ok(())
    }

    /// 处理内容
    fn process_content(&self, content: &str, content_type: ContentType) -> String {
        // 使用插件处理内容
        if let Some(plugin_manager) = &self.plugin_manager {
            match plugin_manager.process_content(content, content_type) {
                Ok(processed) => processed,
                Err(e) => {
                    warn!("内容处理出错: {}", e);
                    content.to_string()
                }
            }
        } else {
            content.to_string()
        }
    }
    
    /// 处理Markdown内容
    fn process_markdown(&self, content: &str) -> String {
        self.process_content(content, ContentType::Markdown)
    }
    
    /// 处理HTML内容
    fn process_html(&self, content: &str) -> String {
        self.process_content(content, ContentType::HTML)
    }
    
    /// 渲染文章内容
    fn render_post_content(&self, post: &mut Post, renderer: &ThemeRenderer) -> Result<()> {
        // 使用插件对Markdown内容进行处理
        let processed_content = self.process_markdown(&post.raw_content);
        
        // 将Markdown转换为HTML
        let html_content = crate::utils::markdown::render(&processed_content)?;
        
        // 使用插件对HTML内容进行处理
        let final_content = self.process_html(&html_content);
        
        post.content = final_content;
        
        Ok(())
    }
    
    /// 渲染页面内容
    fn render_page_content(&self, page: &mut Page, renderer: &ThemeRenderer) -> Result<()> {
        // 使用插件对Markdown内容进行处理
        let processed_content = self.process_markdown(&page.raw_content);
        
        // 将Markdown转换为HTML
        let html_content = crate::utils::markdown::render(&processed_content)?;
        
        // 使用插件对HTML内容进行处理
        let final_content = self.process_html(&html_content);
        
        page.content = final_content;
        
        Ok(())
    }
    
    /// 清理插件资源
    fn cleanup_plugins(&mut self) -> Result<()> {
        info!("清理插件资源...");
        
        if let Some(plugin_manager) = &mut self.plugin_manager {
            if let Err(e) = plugin_manager.cleanup() {
                warn!("清理插件资源失败: {}", e);
                // 继续执行，不中断整个过程
            }
        }
        
        Ok(())
    }
    
    pub fn cleanup(&mut self) -> Result<()> {
        self.cleanup_plugins()?;
        Ok(())
    }
}

/// 辅助函数：将yaml_rust2::Yaml转换为serde_yaml::Value
fn yaml_to_serde_value(yaml: yaml_rust2::Yaml) -> serde_yaml::Value {
    match yaml {
        yaml_rust2::Yaml::Real(s) => {
            if let Ok(f) = s.parse::<f64>() {
                serde_yaml::Value::Number(serde_yaml::Number::from(f))
            } else {
                serde_yaml::Value::String(s)
            }
        },
        yaml_rust2::Yaml::Integer(i) => serde_yaml::Value::Number(serde_yaml::Number::from(i)),
        yaml_rust2::Yaml::String(s) => serde_yaml::Value::String(s),
        yaml_rust2::Yaml::Boolean(b) => serde_yaml::Value::Bool(b),
        yaml_rust2::Yaml::Array(arr) => {
            let values: Vec<serde_yaml::Value> = arr.into_iter()
                .map(yaml_to_serde_value)
                .collect();
            serde_yaml::Value::Sequence(values)
        },
        yaml_rust2::Yaml::Hash(hash) => {
            let mut mapping = serde_yaml::Mapping::new();
            for (k, v) in hash {
                if let yaml_rust2::Yaml::String(key) = k {
                    mapping.insert(serde_yaml::Value::String(key), yaml_to_serde_value(v));
                }
            }
            serde_yaml::Value::Mapping(mapping)
        },
        yaml_rust2::Yaml::Alias(_) => serde_yaml::Value::Null,
        yaml_rust2::Yaml::Null => serde_yaml::Value::Null,
        yaml_rust2::Yaml::BadValue => serde_yaml::Value::Null,
    }
}

/// 将 Pod 类型转换为 serde_yaml::Value
fn pod_to_value(pod: Pod) -> Value {
    match pod {
        Pod::String(s) => Value::String(s),
        Pod::Integer(i) => Value::Number(serde_yaml::Number::from(i)),
        Pod::Float(f) => Value::Number(serde_yaml::Number::from(f)),
        Pod::Boolean(b) => Value::Bool(b),
        Pod::Array(arr) => Value::Sequence(arr.into_iter().map(pod_to_value).collect()),
        Pod::Hash(map) => Value::Mapping(map.into_iter().map(|(k, v)| (Value::String(k), pod_to_value(v))).collect()),
        Pod::Null => Value::Null,
    }
} 